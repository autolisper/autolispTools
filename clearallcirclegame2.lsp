(defun c:clearallcirclegame2 ( / $_device $_data ts ps vs $_code barp barn button isgripbutton tmpt point0 point1 left down size right up oldosmode fieldlines ent rsize ball vlength ang x y v p endt barps barns  time barm ballx bally ballsize bps rs bpsobjects isok bp r i tmppos startp startv textObject pointballs pointballtraj pointnum x y endtext clearobject) 
  (if (not HL:ISLOADUTILITY_LSP)
    (progn 
      (alert "you must load utility.lsp\n")
      (quit)
    )
  )  
  (HL:randinit)
  ;(HL:A_start)
  ;draw play ground
  (while (or (not point0) (not point1) (HL:eqp point0 point1))
  ;get point0
    (setq point0 nil)
    (setq point1 nil)
    (while (not point0)
      (setq point0 (HL:getpointW nil "field corner first point:"))
      (princ "\n")
    )    
  ;get point1  
    (setq point1 (HL:getcornerW point0 "field corner second point:"))
    (princ "\n")
  )  
  ;get size  
  (setq endt 500.0)
  (while (or (not pointnum) (>= 0 pointnum))
    (setq pointnum (getint "number of balls to clear:"))
  )  
  (setq left (min (car point0) (car point1)))
  (setq down (min (cadr point0) (cadr point1)))
  (setq size (min (abs (- (car point0) (car point1))) (abs (- (cadr point0) (cadr point1)))))  
  (setq right (+ left size))
  (setq up (+ down size))      
  (setq rsize (* size 0.035))
  ;draw field
  (setq oldosmode (getvar "OSMODE"))
  (setvar "OSMODE" 0)  
  (setq fieldlines (cons (HL:drawLine (list left down) (list right down)) fieldlines))
  (setq fieldlines (cons (HL:drawLine (list right down) (list right up)) fieldlines))
  (setq fieldlines (cons (HL:drawLine (list right up) (list left up)) fieldlines))
  (setq fieldlines (cons (HL:drawLine (list left up) (list left down)) fieldlines))
  ;zoom to play ground
  (vla-zoomwindow (HL:acadobject) (vlax-3d-point (list (- left (/ size 3)) (- down (/ size 2.0)))) (vlax-3d-point (list (+ right (/ size 3)) (+ up (/ size 10.0) ) )))
  ;inifinite line wall
  (setq barns (list '(0.0 1.0) '(-1.0 0.0) '(0.0 -1.0) '(1.0 0.0)))
  (setq barps (list (list left down) (list right down) (list right up) (list left up)))  
  ;draw player ball
  (setq vlength (/ rsize 2.0))
  ;(setq ang (HL:randreal (* 2.0 pi)))
  (setq ang 0.9)
  ;(setq ang 0.1)
  (setq v (polar (list 0.0 0.0) ang vlength))    
  (setq x (+ left (* rsize 1.25)))
  (setq y (/ (+ up down) 2.0))
  (setq p (list x y))
  (setq startp p)
  (setq startv v)
  (setq ball (HL:drawCircle p rsize))     
  (vla-put-color ball 1)
  ;(setq bps (list (list (/ (+ left right) 2.0) (/ (+ down up) 2.0) )))
  ;(setq rs (list (* rsize 8.0)))  
  ;(setq bpsobjects (mapcar '(lambda ( pos radius) (HL:drawCircle pos radius)) bps rs))  
  ;draw switch
  ;draw bar
  ;calc trajectory 
  (defun HL:calctrajectory ( / nowt nowb nowc preb prec intervalt i barn barp tmpt nextt nextp nextv bcenter bradius vlength a b x0 y0 c xc yc DD PP AA BB)
  (setq ts (list 0.0))
  (setq ps (list startp))
  (setq vs (list startv))  
  (setq p startp)
  (setq v startv)
  (setq nowt 0.0)    
  (setq nowb -1)
  (setq nowc -1)
  (setq preb -1)
  (setq prec -1)  
  (while (< nowt endt)     
    (setq intervalt 100000.0)
    ;calc time to collid outerwall
    (setq i 0)
    (repeat (length barns)             
      (setq barn (nth i barns))
      (setq barp (nth i barps))
      (setq barp (HL:+L barp (HL:scalarMul rsize barn)));corelate rsize
      (if (and (not (= preb i)) (not (HL:eqr (HL:innerproduct barn v) 0.0) ))
          (progn            
            (setq tmpt (/ (HL:innerproduct (HL:-L barp p) barn) (HL:innerproduct barn v)))
            ;if time is min and intervalt < endt ,overwrite nextp nextv intervalt
            ;TODO not collid with previous
            (if (and (< 0 tmpt) (< tmpt intervalt) (not (HL:eqr tmpt 0.0)))
              (progn
                (setq intervalt tmpt)
                (setq nextt (+ nowt intervalt))
                (setq nextp (HL:+L p (HL:scalarMul intervalt v)))
                (setq nextv (HL:-L v (HL:scalarMul (* 2.0 (HL:innerproduct v barn)) barn)))              
                (setq nowb i)
                (setq nowc -1)
              )
            )
          )
      )      
      (setq i (1+ i))
    )  
    (setq i 0)

    ;calc time to collid circle    
    (repeat (length bps)
      ;calc intervalt
      (setq bcenter (nth i bps))
      (setq bradius (+ (nth i rs) rsize))      
      ;(setq bradius (nth i rs))
      (setq vlength (HL:getL v))
      (setq a (/ (cadr v) vlength))
      (setq b (/ (HL:neg (car v)) vlength))
      (setq x0 (car p))
      (setq y0 (cadr p))
      (setq c (HL:neg (+ (* a x0) (* b y0))))      
      (setq xc (car bcenter))
      (setq yc (cadr bcenter))
      (setq DD (+ (* a xc) (* b yc) c))
      ; if collid
      (if (and (not (= prec i)) (>= bradius (abs DD)))
          (progn
            (setq PP (sqrt (- (* bradius bradius) (* DD DD))))
            (setq AA (list (+ (- (* b PP) (* a DD)) xc) (- yc (+ (* b DD) (* a PP)))))
            (setq BB (list (- xc (+ (* b PP) (* a DD))) (+ (- (* a PP) (* b DD)) yc)))   
            ;(HL:drawCircle AA rsize)
            ;(HL:drawCircle BB rsize)            
            ;not minus time
            (if (> (HL:innerproduct v (HL:-L bcenter p)) 0)
              ;calc time
              (progn 
                (setq tmpt (/ (HL:getD AA p) vlength))
                (if (and (< 0 tmpt) (< tmpt intervalt) (not (HL:eqr tmpt 0.0)))
                  (progn
                    (setq intervalt tmpt)
                    (setq nextt (+ nowt intervalt))
                    (setq nextp (HL:+L p (HL:scalarMul intervalt v)))
                    (setq barn (HL:-L nextp bcenter))
                    (setq barn (HL:lengthV barn 1.0))
                    (setq nextv (HL:-L v (HL:scalarMul (* 2.0 (HL:innerproduct v barn)) barn)))                                
                    (setq nowb -1)
                    (setq nowc i)
                    ;(HL:drawCircle AA rsize)
                  )
                )
              )
            )
            (if (> (HL:innerproduct v (HL:-L bcenter p)) 0)
              (progn
                (setq tmpt (/ (HL:getD BB p) vlength))
                (if (and (< 0 tmpt) (< tmpt intervalt) (not (HL:eqr tmpt 0.0)))
                  (progn
                    (setq intervalt tmpt)
                    (setq nextt (+ nowt intervalt))
                    (setq nextp (HL:+L p (HL:scalarMul intervalt v)))
                    (setq barn (HL:-L nextp bcenter))
                    (setq barn (HL:lengthV barn 1.0))
                    (setq nextv (HL:-L v (HL:scalarMul (* 2.0 (HL:innerproduct v barn)) barn)))                                
                    (setq nowb -1)
                    (setq nowc i)
                    ;(HL:drawCircle BB rsize)
                  )
                )
              )
            )
          )
      )
      (setq i (1+ i))
    )
    (if (<= endt (+ nowt intervalt))
      (progn
        (setq nextt endt)
        (setq nextp (HL:+L p (HL:scalarMul (- endt nowt) v)))
        (setq nextv v)
      )
    )
    ;setq
    (setq ts (cons nextt ts))
    (setq ps (cons nextp ps))
    (setq vs (cons nextv vs))
    (setq nowt nextt)
    (setq p nextp)
    (setq v nextv)    
    (setq preb nowb)
    (setq prec nowc)
    ;(HL:drawCircle p rsize)
    ;(HL:addTextCenter p rsize (strcat (itoa preb) (itoa prec)))
    ;(vla-put-center ball (vlax-3d-point p))
    ;(vla-update ball)    
    ;(getpoint)
  )  
  (setq ts (reverse ts))
  (setq ps (reverse ps))
  (setq vs (reverse vs))
    ;calc pointballtraj
  (HL:calcpointballtraj)  
  )
  (defun HL:getNextCollidPointBall ( remainballs p v maxinterval / pb bcenter bradius vlength a b x0 y0 c xc yc DD PP AA BB v p collidnum i)
    ;calc intervalt
    (setq intervalt maxinterval)    
    (setq collidnum nil)    

    (foreach i remainballs
      (setq pb (nth i pointballs))
      (setq bcenter (vlax-safearray->list (vlax-variant-value (vla-get-center pb))))
      (setq bradius (+ (vla-get-radius pb) rsize))                  
      (setq vlength (HL:getL v))
      (setq a (/ (cadr v) vlength))
      (setq b (/ (HL:neg (car v)) vlength))      
      (setq x0 (car p))
      (setq y0 (cadr p))
      (setq c (HL:neg (+ (* a x0) (* b y0))))      
      (setq xc (car bcenter))
      (setq yc (cadr bcenter))
      (setq DD (+ (* a xc) (* b yc) c))
      ; if collid
      (if (>= bradius (abs DD))
          (progn
            (setq PP (sqrt (- (* bradius bradius) (* DD DD))))
            (setq AA (list (+ (- (* b PP) (* a DD)) xc) (- yc (+ (* b DD) (* a PP)))))
            (setq BB (list (- xc (+ (* b PP) (* a DD))) (+ (- (* a PP) (* b DD)) yc)))   
            ;(HL:drawCircle AA rsize)
            ;(HL:drawCircle BB rsize)            
            ;not minus time
            (if (> (HL:innerproduct v (HL:-L bcenter p)) 0)
              ;calc time
              (progn 
                (setq tmpt (/ (HL:getD AA p) vlength))
                (if (and (< 0 tmpt) (< tmpt intervalt) (< tmpt maxinterval) (not (HL:eqr tmpt 0.0)))
                  (progn
                    (setq intervalt tmpt)
                    (setq collidnum i)
                    ;(HL:drawCircle AA rsize)
                  )
                )
              )
            )
            (if (> (HL:innerproduct v (HL:-L bcenter p)) 0)
              (progn
                (setq tmpt (/ (HL:getD BB p) vlength))
                (if (and (< 0 tmpt) (< tmpt intervalt) (not (HL:eqr tmpt 0.0)))
                  (progn
                    (setq intervalt tmpt)
                    (setq collidnum i)                    
                  )
                )
              )
            )
          )
      )      
    )  
    (if collidnum
      (list (vl-remove collidnum remainballs) intervalt)
      (list remainballs 0.0)
    )
  )
  (defun HL:calcpointballtraj ( / i tpre tpost p v iscollid ret remainballs )
    (setq i 0)
    (setq remainballs nil)
    (repeat (length pointballs)
      (setq remainballs (cons i remainballs))
      (setq i (1+ i))
    )
    (setq remainballs (reverse remainballs))
    (setq pointballtraj nil)
    (setq pointballtraj (cons (list 0.0 remainballs) pointballtraj))
    (setq i 0)    
    (repeat (1- (length ts))
      (setq tpre (nth i ts))
      (setq tpost (nth (1+ i) ts))      
      (setq iscollid T)      
      ;while not collid
      (while iscollid
        ;get nearest collid ball        
        (setq ret (HL:getNextCollidPointBall remainballs (HL:getPosition tpre) (HL:getVelocity tpre) (- tpost tpre)))
        (if (= (length remainballs) (length (car ret)))
            (setq iscollid nil)
            (progn
              (setq remainballs (car ret))
              (setq tpre (+ tpre (cadr ret)))
              (setq pointballtraj (cons (list tpre remainballs) pointballtraj))    
            )
        )
      )
      (setq i (1+ i))
    )
    ;last trajectory
    (setq pointballtraj (cons (list endt remainballs) pointballtraj))
    (setq pointballtraj (reverse pointballtraj))    
  )
  (defun HL:getVelocity ( nowt / i ansi time)        
    (setq i 0)
    (setq ansi -10)    
    (foreach time ts      
      (if (and (> 0 ansi) (< nowt time))  
        (progn
          (setq ansi (1- i))          
        )
      )
      (setq i (1+ i))
    )
    (if (< ansi 0)
      (setq ansi (- (length ts) 1))
    )    
    (nth ansi vs)
  )  
  (defun HL:getPosition ( nowt / i ansi time)        
    (setq i 0)
    (setq ansi -10)    
    (foreach time ts      
      (if (and (> 0 ansi) (< nowt time))  
        (progn
          (setq ansi (1- i))          
        )
      )
      (setq i (1+ i))
    )
    (if (< ansi 0)
      (setq ansi (- (length ts) 1))
    )    
    (HL:+L (nth ansi ps) (HL:scalarMul (- nowt (nth ansi ts)) (nth ansi vs)))
  )  
  (defun HL:creatCircleButton (pos r )
    (list pos r (HL:drawCircle pos r))
  )
  (defun HL:moveCircleButton (button pos)
    (vla-put-center (caddr button) (vlax-3d-point pos))
    (vla-update (caddr button))            
    (list pos (cadr button) (caddr button))
  )
  (defun HL:isInButton (button pos)
    (< (HL:getD (car button) pos) (cadr button))
  )
  (defun HL:isInField (pos r / posleft posright posup posdown posx posy)
      (setq posx (car pos))
      (setq posy (cadr pos))
      (setq posleft (- posx r))
      (setq posright (+ posx r))
      (setq posdown (- posy r))
      (setq posup (+ posy r))
      (and (<= left posleft) (<= posright right) (<= down posdown) (<= posup up))
  )
  (defun HL:isCollidBPS (circlepos circlesize / i pos r collidnum)
    (setq i 0)
    (setq collidnum nil)
    (repeat (length bps)
      (setq pos (nth i bps))
      (setq r (nth i rs))
      (if (and (not collidnum) (< (HL:getD pos circlepos) (+ circlesize r)))
          (progn
            (setq collidnum i)
          )
      )
      (setq i (1+ i))
    )    
    collidnum
  )
  (defun HL:getCollidPointBalls (circlepos circlesize / pb i pos r collidnum)
    (setq i 0)
    (setq collidnum nil)
    (repeat (length pointballs) 
      (setq pb (nth i pointballs))
      (setq pos (vlax-safearray->list (vlax-variant-value (vla-get-center pb))))
      (setq r (vla-get-radius pb))
      (if (< (HL:getD pos circlepos) (+ circlesize r))
          (progn
            (setq collidnum (cons i collidnum))
          )
      )
      (setq i (1+ i))
    )    
    collidnum
  )
  (defun HL:getRemainCollidballs ( nowt / i ansi time pj)    
    (setq i 0)
    (setq ansi -10)    
    (foreach pj pointballtraj      
      (setq time (car pj))      
      (if (and (> 0 ansi) (< nowt time))  
        (progn
          (setq ansi (1- i))          
        )
      )
      (setq i (1+ i))
    )    
    (if (< ansi 0)
      (setq ansi (- (length pointballtraj) 1))
    )    
    (cadr (nth ansi pointballtraj))
  )
  (defun HL:setPointballs (tmpt / remainballs i)    
    (setq remainballs (HL:getRemainCollidballs tmpt))      
    (setq i 0)    
    (repeat (length pointballs)
      (if (member i remainballs)
          (vla-put-radius (nth i pointballs) rsize)
          (vla-put-radius (nth i pointballs) (* size 10.0) )
      )
      (setq i (1+ i))
    )    
  )
  (defun HL:getInBPS (circlepos / i pos r collidnum)
    (setq i 0)
    (setq collidnum -1)
    (repeat (length bps)
      (setq pos (nth i bps))
      (setq r (nth i rs))
      (if (and (= collidnum -1) (< (HL:getD pos circlepos)  r))
          (progn
            (setq collidnum i)
          )
      )
      (setq i (1+ i))
    )    
    collidnum
  )
  ;if nil not collid, if number -1 collid ball or field if number >=0 bps
  (defun HL:checkBPS (circlepos circlesize / bpsnum)
    ;check is in field
    (if (not (HL:isInField circlepos circlesize))
        -1
        (progn
          ;check not collid ball
          (if (< (HL:getD startp circlepos) (+ circlesize rsize))
            -1
            (progn
              (if (HL:isCollidBPS circlepos circlesize)
                  (progn                      
                     (HL:getInBPS circlepos)
                  )
                  nil
              )   
            )   
          )
        )
    )
    ;check not collid ball in bps if collid return n
  )
  ;draw bar
  (setq barm (/ size 5.0))
  (setq fieldlines (cons (HL:drawLine (list left (- down barm)) (list right (- down barm))) fieldlines))
  (setq ballx left)
  (setq bally (- down barm))
  (setq ballsize rsize)
  (setq button (HL:creatCircleButton (list ballx bally) ballsize))
  ;change time
  (setq isgripbutton nil)
  ;add edit or playing text
  (setq textObject (HL:addTextCenter (list (/ (+ left right) 2.0) (- down (/ barm 2.0))) ballsize "editing"))
  ;point ball add
  (defun HL:addPointBall ( x y r )
    (if (and (not (HL:checkBPS (list x y) r)) (not (HL:getCollidPointBalls (list x y) r))) 
        (HL:_addPointBall x y r)
        nil
    )
  )
  (defun HL:_addPointBall (x y r / pointball )
    (setq pointball  (HL:drawCircle (list x y) r))
    (vla-put-color pointball 2)
    (setq pointballs (cons pointball pointballs))    
  )
  (defun HL:flipText ()
    (if isgripbutton 
        (vla-put-textstring textObject "playing")
        (vla-put-textstring textObject "editing")
    )
  )
  (setq isok nil)
  (while (not isok)
    (setq i 0)  
    (while (< i pointnum)
      (setq x (HL:randrealrange (+ left rsize) (- right rsize)))
      (setq y (HL:randrealrange (+ down rsize) (- up rsize)))
      (if (HL:addPointBall  x y ballsize)
          (setq i (1+ i))
      )
    )
    (HL:calctrajectory)
    ; clear
    (if (= (length (HL:getRemainCollidballs endt)) 0)
        (progn
          (setq isok nil)
          (foreach ent pointballs
            (vla-delete ent)
          )
          (setq pointballs nil)
        )
        (setq isok T)
    )
  )
  (setq isok nil)
  (while (not isok)
    (setq $_device (grread T (+ 1 2 4 8) 0)
              $_code   (car $_device)
              $_data   (cadr $_device)
    )        
    (cond ((= $_code 3)                   ;Mouse Click      
        (progn          
          (if (HL:isInButton button $_data)
              (progn
                (setq isgripbutton (not isgripbutton))                
                (HL:flipText)
                (if (not isgripbutton)
                    (progn
                      (setq ballx left)
                      (setq button (HL:moveCircleButton button (list ballx bally)))
                      (vla-put-center ball (vlax-3d-point (HL:getPosition 0.0)))
                      (vla-update ball)        
                      (HL:setPointballs 0.0)
                    )
                    (progn
                      (HL:calctrajectory)
                    )
                )
              )
              (if isgripbutton
                (progn
                  (setq isgripbutton (not isgripbutton))
                  (HL:flipText)
                  (if (not isgripbutton)
                    (progn
                      (setq ballx left)
                      (setq button (HL:moveCircleButton button (list ballx bally)))
                      (vla-put-center ball (vlax-3d-point (HL:getPosition 0.0)))
                      (vla-update ball)     
                      (HL:setPointballs 0.0)
                    )
                  )
                )
                (progn ; add ball
                  (setq tmppos $_data)                  
                  ;check
                  (setq i (HL:checkBPS tmppos rsize))
                  (if (HL:getCollidPointBalls tmppos rsize)
                      (setq i -1)
                  )
                  (cond ((not i) ; not collid
                    (progn
                      (setq bps (cons tmppos bps))
                      (setq rs (cons rsize rs))  
                      (setq bpsobjects (cons (HL:drawCircle tmppos rsize) bpsobjects))
                    )
                  )
                  ((>= i 0)
                   (progn ; bps number i in 
                      ;remove i th bps                     
                      (vla-delete (nth i bpsobjects))
                      (setq bps (HL:removeNth i bps))
                      (setq rs (HL:removeNth i rs))
                      (setq bpsobjects (HL:removeNth i bpsobjects))
                    )
                  )  
                  )
                )
              )
          )
        )
        )
        ((= $_code 5)
          (if isgripbutton
            (progn
              (setq ballx (car $_data))
              (if (< ballx left)
                  (setq ballx left)
              )
              (if (> ballx right)
                  (setq ballx right)
              )
              (setq button (HL:moveCircleButton button (list ballx bally)))
              (setq tmpt (* endt (/ (- ballx left) (- right left))))
              (vla-put-center ball (vlax-3d-point (HL:getPosition tmpt)))
              (vla-update ball)        
              (HL:setPointballs tmpt)
              ; clear
              (if (= (length (HL:getRemainCollidballs tmpt)) 0)
                  (setq isok 1)
              )
            )
          )
        )  
        ((= $_code 2)                     
          (cond 
                ((= $_data 113)
                  (setq isok T)
                )
          )          
        )
    )    
  )
  (setq endtext (if (= isok 1) "clear!! click to end" "game over!! click to end"))  
  (setq clearobject (HL:addTextCenter (HL:scalarMul 0.5 (HL:+L (list left down) (list right up))) (/ size 10)  endtext))
  (vla-put-color clearobject 1)
  (command-s "._draworder" (vlax-vla-object->ename clearobject) "" "F")  
  (getpoint)
  (vla-delete clearobject)
  ;(setq time 0.0)  
  ;(while (< time  endt )
  ;  (setq time (+ time 0.4))        
  ;  (vla-put-center ball (vlax-3d-point (HL:getPosition time)))
  ;  (vla-update ball)        
  ;)
  ;redraw  
  ;(getpoint)
  ;delete all
  (foreach ent fieldlines 
    (vla-delete ent)
  )
  (foreach ent bpsobjects
    (vla-delete ent)
  )
  (foreach ent pointballs
    (vla-delete ent)
  )
  (vla-delete ball)
  (vla-delete textObject)
  (vla-delete (caddr button))
  (setvar "OSMODE" oldosmode)  
  ;(HL:A_end)
)