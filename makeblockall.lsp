;return (ent (point1 . point2 ))
(defun HL:isCrossRange ( min0 max0 min1 max1)
  (or (and (<= min0 min1) (<= min1 max0 )) (and (<= min0 max1) (<= max1 max0 ))
      (and (<= min1 min0) (<= min0 max1 )) (and (<= min1 max0) (<= max0 max1 ))
  )
)
(defun HL:isBoundingBoxCross ( pcons0 pcons1 / p0min p0max p1min p1max)  
  (setq p0min (car pcons0))
  (setq p0max (cdr pcons0))
  (setq p1min (car pcons1))
  (setq p1max (cdr pcons1))
  (and (HL:isCrossRange (car p0min) (car p0max) (car p1min) (car p1max))
       (HL:isCrossRange (cadr p0min) (cadr p0max) (cadr p1min) (cadr p1max))
  )
)
(defun HL:mergeBoundingBox ( b0 b1 / p0min p0max p1min p1max)
  (setq p0min (car b0))
  (setq p0max (cdr b0))
  (setq p1min (car b1))
  (setq p1max (cdr b1))
  (cons (list (min (car p0min) (car p1min)) (min (cadr p0min) (cadr p1min))) (list (max (car p0max) (car p1max)) (max (cadr p0max) (cadr p1max))))
)
(defun HL:insertBoundingBox (allblocklist insertb ent / ab bb)  
  (if allblocklist
      (progn
        (setq ab (car allblocklist))
        (setq bb (car ab))
        (if (HL:isBoundingBoxCross bb insertb)
            (cons (cons (HL:mergeBoundingBox bb insertb) (cons ent (cdr ab))) (cdr allblocklist))
            (cons ab (HL:insertBoundingBox (cdr allblocklist) insertb ent))
        )
      )
      (list (cons insertb (list ent)))
  )
)
(defun c:makeblockall ( / selectset ent allblocklist tmp myset point)
  (HL:A_start)
  (setq selectset (HL:getNameList (ssget '((0 . "ARC,CIRCLE,LINE,LWPOLYLINE,SPLINE,ELLIPSE")))))
  (foreach ent selectset    
    (setq allblocklist (HL:insertBoundingBox allblocklist (HL:getBoundingBox ent) ent))
  )
  (foreach tmp allblocklist
    (setq myset (HL:toSet (cdr tmp)))    
    (setq point (caar tmp))
    (setq point (list (car point) (cadr point) 0.0))    
    (setq point (trans point 0 1))      
    (command-s "._copybase" point myset "")
    (command-s "._pasteblock" point)
    (command-s "._erase" myset "")
  )  
  (HL:A_end)
)