;return (ent (point1 . point2 ))

(defun HL:insertBoundingBox (allblocklist insertb ent / ab bb)  
  (if allblocklist
      (progn
        (setq ab (car allblocklist))
        (setq bb (car ab))
        (if (HL:isBoundingBoxCross bb insertb)
            (cons (cons (HL:mergeBoundingBox bb insertb) (cons ent (cdr ab))) (cdr allblocklist))
            (cons ab (HL:insertBoundingBox (cdr allblocklist) insertb ent))
        )
      )
      (list (cons insertb (list ent)))
  )
)
(defun c:makeblockall ( / selectset ent allblocklist tmp myset point)
  (if (not HL:ISLOADUTILITY_LSP)
    (progn 
      (alert "you must load utility.lsp\n")
      (quit)
    )
  )  
  (HL:A_start)
  (setq selectset (HL:getNameList (ssget '((0 . "ARC,CIRCLE,LINE,LWPOLYLINE,SPLINE,ELLIPSE,INSERT")))))
  (foreach ent selectset    
    (setq allblocklist (HL:insertBoundingBox allblocklist (HL:getBoundingBox ent) ent))
  )
  (foreach tmp allblocklist
    (setq myset (HL:toSet (cdr tmp)))    
    (setq point (caar tmp))
    (setq point (list (car point) (cadr point) 0.0))    
    (setq point (trans point 0 1))      
    (command-s "._copybase" point myset "")
    (setq tmp (entlast))
    (while (eq tmp (entlast))
      (command-s "._pasteblock" point)
    )
    (command-s "._erase" myset "")
  )  
  (HL:A_end)
)