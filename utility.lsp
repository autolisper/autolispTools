
(setq HL:ISLOADUTILITY_LSP T)
(setq HL:CUSTOMEQUALQUALITY 0.00000001)
;common command
(defun HL:saveVar()
         (setq HL:OldOsmode (getvar "OSMODE"))
	(setq HL:OldLayer (getvar "CLAYER"))
	(setq HL:OldLType (getvar "CeLType"))
	(setq HL:OldColor (getvar "CeColor"))
	(setq HL:OldOrtho (getvar "ORTHOMODE"))
	(setq HL:OldDStyle  (getvar "DIMSTYLE"))
  (princ)
)
(defun HL:restoreVar()
  (setvar "OSMODE" HL:OldOsmode)
  (setvar "CLAYER" HL:OldLayer)
	(setvar "CeLType" HL:OldLType)
	(setvar "CeColor" HL:OldColor)
	(setvar "ORTHOMODE" HL:OldOrtho)
	(if (and (/= (getvar "DIMSTYLE") HL:OldDStyle)(tblsearch "DIMSTYLE" HL:OldDStyle))
	(command "-dimstyle" "Restore" HL:OldDStyle)
	)
  (princ)
) 
(defun HL:A_start ()
        (setq HL:OldCmdEcho (getvar "CMDECHO"))
	(setvar "CMDECHO" 0)
        (setq *error* HL:*myerror*)
        (*push-error-using-command*) 
	(command "undo" "be")	
	(princ)
)


(defun HL:AU_end ()
	(command "undo" "end")	
	(setvar "CMDECHO" HL:OldCmdEcho)
        (setq *error* nil)
	(princ)
)
(defun HL:A_end ()
	(HL:AU_end)
        (*pop-error-mode*) 
	(princ)
)
(defun HL:A_errorEnd()
  (HL:AU_end)
  (command "._U")
  (*pop-error-mode*)
  (princ)
)


(defun HL:*myerror* (msg)
	(HL:A_errorEnd)
	(princ msg)
	(princ)
)


(defun HL:A_dxf (g e)
	(cond
		((= (type e) 'ename) (cdr (assoc g (entget e))))
		((= (type e) 'list) (cdr (assoc g e)))
	)
)

(defun HL:U_dxf (g u e )
  (setq e
	(cond
		((= (type e) 'ename) (entget e))
		((= (type e) 'list) e)
	)
  )
  (if (assoc g e)
     (subst (cons g u) (assoc g e) e)
     (cons (cons g u) e)
  )
)
;*************point to string******
(defun HL:ptos (point)
  (strcat (rtos (car point)) " " (rtos (cadr point)))
  )
;*************"1,1"=> ("1","1")*****
(defun HL:split (SD_Str / DataTemp m DataS DataN SD_List)
            (setq DataTemp (vl-string->list SD_Str))
            (setq m 0)
            (repeat (length DataTemp)
            (if     (/= (nth m DataTemp) 32)
                (setq DataS (append DataS (list (nth m DataTemp))))
                (progn  (setq DataN (append DataN (list DataS)))
                        (setq DataS nil)
                )
            )
            (setq m (1+ m))
            )
            (setq DataN (append DataN (list DataS)))
            (setq SD_List (mapcar 'vl-list->string DataN))
            SD_List
        )
;take num from head
(defun HL:take (pL num)
  (if (or (not pL) (= num 0))
      nil
      (cons (car pL) (HL:take (cdr pL) (1- num)))
  )
  )
;list plus
(defun HL:+L (aL bL)
  (if (and aL bL)
      (cons (+ (car aL) (car bL)) (HL:+L (cdr aL) (cdr bL)))
    nil
    )
)
(defun HL:-L (aL bL)
  (if (and aL bL)
      (cons (- (car aL) (car bL)) (HL:-L (cdr aL) (cdr bL)))
    nil
    )
)
(defun HL:lessp (a b)
  (if (HL:eqr a b)
      t
      (<= a b)
  )
)
(defun HL:getD (p0 p1 / xx yy)
  (setq xx (- (car p0) (car p1)))
  (setq yy (- (cadr p0) (cadr p1)))
  (sqrt (+ (* xx xx) (* yy yy)))
)
(defun HL:getL (p0 / xx yy)
  (setq xx (car p0))
  (setq yy (cadr p0))
  (sqrt (+ (* xx xx) (* yy yy)))
)
;;return vector V length l
(defun HL:lengthV (v l / d)
  (setq d (HL:getL v))
  (list (* (/ (car v) d) l) (* (/ (cadr v) d) l))
)

(defun HL:rotate90 (v)
  (list (cadr v)(- 0 (car v)))
)
(defun HL:scalarMul(a aL)
  (mapcar '(lambda (x) (* a x)) aL)
)
(defun HL:outerproduct ( v0 v1 / )
  (- (* (car v0) (car (cdr v1))) (* (car v1) (car (cdr v0))))
)
(defun HL:innerproduct ( v0 v1 / )
  (+ (* (car v0) (car v1)) (* (cadr v0) (cadr v1)))
)
(defun HL:neg (a)
  (- 0 a)
)
;real eq
(defun HL:eqr(x y)
  (equal x y HL:CUSTOMEQUALQUALITY)
)
;2d point <
(defun HL:compp (p0 p1 / x0 x1 y0 y1)
  (setq x0 (car p0))
  (setq y0 (cadr p0))
  (setq x1 (car p1))
  (setq y1 (cadr p1))
  (if (equal x0 x1 HL:CUSTOMEQUALQUALITY)
      (< y0 y1)
      (< x0 x1)
  )
)
;2d point eq
(defun HL:eqp (p0 p1 / x0 x1 y0 y1)
  (setq x0 (car p0))
  (setq y0 (cadr p0))
  (setq x1 (car p1))
  (setq y1 (cadr p1))
  (if (HL:eqr x0 x1)
      (HL:eqr y0 y1)
      nil
  )
)
;get All curve around point
(defun HL:getCurveSetAroundPoint (point)
  (ssget "_C" (HL:+L point '(0.1 0.1)) (HL:+L point '(-0.1 -0.1)) '((0 . "ARC,CIRCLE,LINE,LWPOLYLINE,SPLINE,ELLIPSE")))
)

(defun HL:isCurve (item)
   (member (HL:A_dxf 0 item) '("ARC" "CIRCLE" "LINE" "LWPOLYLINE" "SPLINE" "ELLIPSE"))
)
;point is on curve except oname
(defun HL:isOnCurve(oname point / ObjSet i0 name isok)
  (setq ObjSet (HL:getCurveSetAroundPoint point))
  (setq i0 -1)
  (setq isok nil)
  (if (not ObjSet)
     nil;(progn (princ "オブジェクトなし") (princ))
     (progn
       (repeat (sslength ObjSet)
        (setq name (ssname ObjSet (setq i0 (1+ i0))))
        (if (equal name oname)
           nil
           (if (HL:eqp (vlax-curve-getClosestPointTo  name point) point)
             (setq isok t)
          )
        )
     )
     isok
     )
 )
)
(defun HL:isOnCurveEndPoint(oname point / ObjSet i0 name pointL isOn p)
  (setq ObjSet (HL:getCurveSetAroundPoint point))
  (setq i0 -1)
  (setq pointL nil)
  (if (not ObjSet)
    nil
    (progn 
  (repeat (sslength ObjSet)
	  (setq name (ssname ObjSet (setq i0 (1+ i0))))
    	  (if (not (equal name oname))
    	      (setq pointL (cons (vlax-curve-getEndPoint name ) (cons (vlax-curve-getStartPoint name) pointL)))
          )
  )
  (setq isOn nil)
  (foreach p pointL
    (if (HL:eqp p point)
        (setq isOn t)
    )
  )
  isOn
  )
  )
)
(defun HL:isOnCurveEndAndQuadrantPoint(oname point / ObjSet i0 name pointL isOn p)
  (setq ObjSet (HL:getCurveSetAroundPoint point))
  (setq i0 -1)
  (setq pointL nil)
  (if (not ObjSet)
    nil
    (progn 
  (repeat (sslength ObjSet)
	  (setq name (ssname ObjSet (setq i0 (1+ i0))))
    	  (if (not (equal name oname))
	      (progn
    	        (setq pointL (cons (vlax-curve-getEndPoint name ) (cons (vlax-curve-getStartPoint name) pointL)))
		(cond ((or (= (HL:getType name) "ARC") (= (HL:getType name) "CIRCLE")) (setq pointL (append (HL:getQuadrantPoint name) pointL)))
		      ((= (HL:getType name) "ELLIPSE") (setq pointL (append (HL:getEllipseQuadrantPoint name) pointL)))
		)
	      )
          )
  )
  (setq isOn nil)
  (foreach p pointL
    (if (HL:eqp p point)
        (setq isOn t)
    )
  )
  isOn
  )
  )
)

;select set to ename list
(defun HL:getNameList (set / pL i)
  (if (/= set nil)
    (progn
  (setq i 0)
  (repeat (sslength set)
      (setq pL (cons (ssname set i) pL))
      (setq i (1+ i))
  )
  pL
  )
  nil
  )
)

(defun HL:getCurveLength (item)
  (vlax-curve-getDistAtParam item (vlax-curve-getEndParam item))
)
;ename list to select set
(defun HL:toSet(nL / ss item)
  (setq ss (ssadd))
  (foreach item nL
    (setq ss (ssadd item ss))
  )
)

(defun HL:changeColor(e c)
  (command-s "._chprop" e "" "C" c "")
)
;recursively exploce blocks and return the list of enames
(defun HL:explodeBlocksAndGetNameList(nL / name tL rL)
  (while nL
   (setq tL nil)
   (foreach name nL
     (if (or (equal (HL:A_dxf 0 name) "LWPOLYLINE")(equal (HL:A_dxf 0 name) "INSERT"))
         (progn 
          (command "._explode" name)
           (setq tL (append (HL:getNameList (ssget "p")) tL))
	 )
         (setq rL (cons name rL))
     )
   )
   (setq nL tL)
  )
  rL
)
(defun HL:changeToBlock ( ss )
  (if (listp ss)
      (setq ss (HL:toSet ss))
  )
  (command "._copybase" '(0 0) ss "")
  (command "._pasteblock" '(0 0))
  (command "._erase" ss "")
  (princ)
)
;return the ename list of block
(defun HL:getBlockEntities (insertBlockName / entity rL)
  (setq entity (tblobjname "block" (HL:A_dxf 2 insertBlockName)))
  (while (setq entity (entnext entity))
    (setq rL (cons entity rL))
  )
)
;
(defun HL:intersparse (list object)
  (if (cdr list)
      (cons (car list) (cons object (HL:intersparse (cdr list) object)))
      list
    )
)
;
(defun HL:joinStr(strList str)
  (apply 'strcat (HL:intersparse strList str))
  )
(defun HL:isInAngle(sa ea a)
  (while (>= sa (* 2 pi))
     (setq sa (- sa (* 2 pi)))
  )
  (while (>= ea (* 2 pi))
     (setq ea (- ea (* 2 pi)))
  )
  (if (HL:eqr sa ea)
       t
      (if (HL:lessp sa ea)
        (and (HL:lessp sa a) (HL:lessp a ea))
        (or (and (HL:lessp sa a) (HL:lessp a (* 2.0 PI))) (and (HL:lessp 0 a) (HL:lessp a ea)))
      )
  )
)
;;
(defun HL:getType (o)
  (HL:A_dxf 0 o)
)
(defun HL:getRadius(o)
  (HL:A_dxf 40 o)
)
(defun HL:getStartAngle(o)
  (HL:A_dxf 50 o)
)
(defun HL:getEndAngle(o)
  (HL:A_dxf 51 o)
)
(defun HL:getColor(o)
  (HL:A_dxf 62 o)
)
(defun HL:getCenter(o)
  (HL:A_dxf 10 o)
)
(defun HL:get90D()
  (* 0.5 pi)
)
(defun HL:get180D()
  (* 1.0 pi)
)
(defun HL:get270D()
  (* 1.5 pi)
)
;return point on object o at angle a
(defun HL:getCirclePoint (o a / otype)
  (setq otype (HL:getType o))
  (if (or (equal otype "ARC") (equal otype "CIRCLE"))
      (polar (HL:getCenter o) a (HL:getRadius o))
      (ErrorNotArcOrCircle)
  )
)
(defun HL:_getEdgePoint(o / sa ea cp r sp ep)
  (setq sa (HL:getStartAngle o))
  (setq ea (HL:getEndAngle o))
  (setq cp (HL:getCenter o))
  (setq r (HL:getRadius o))
  (setq sp (polar cp sa r))
  (setq ep (polar cp ea r))
  (inters sp (polar sp (+ sa (HL:get90D)) r) ep (polar ep (+ ea (HL:get90D)) r) nil)
)
;;ARC intersect point; fillet point
(defun HL:getEdgePoint(o / otype)
  (setq otype (HL:getType o))
  (if (equal otype "ARC")
      (HL:_getEdgePoint o)
      (ErrorNotARC)
  )
)
(defun HL:vlax-ldata-erase (dict / key)
  (foreach key (mapcar 'car (vlax-ldata-list dict)) (vlax-ldata-delete dict key))
  )
(defun HL:changeToGroup (objSet)
  (command "._group" "C" "*" "*" objSet "")
  )
(defun HL:getQuadrantPoint(o / angleL a sA eA)
  (setq angleL nil)
  (setq sA (HL:getStartAngle o))
  (setq eA (HL:getEndAngle o))
  (foreach a (list 0 (HL:get90D) (HL:get180D) (HL:get270D))
    (if (or (= (HL:getType o) "CIRCLE") (HL:isInAngle sA eA a))
        (setq angleL (cons (HL:getCirclePoint o a) angleL))
    )
  )
  angleL
)
(defun HL:getIntersectPoints (ename0 ename / intPoints tempPoint pl)
  (setq intPoints (vla-IntersectWith (vlax-ename->vla-object ename0) (vlax-ename->vla-object ename) acExtendNone))         
  (if (/= (type intPoints) vlax-vbEmpty)        
      (progn
        (setq tempPoint (vlax-safearray->list (vlax-variant-value intPoints)))  ;交点リストを取得
        (while tempPoint
          (setq
            pl (cons (list (car tempPoint) (cadr tempPoint) (caddr tempPoint)) pl)
            tempPoint (cdddr tempPoint)
          )
        )
      )
  )
  pl
)
(defun HL:getEllipseQuadrantPoint(o / angleL center vecx vecy ratio sA eA pairList i)
  (setq angleL nil)
  (setq center (HL:getCenter o))
  (setq ratio (HL:A_dxf 40 o))
  (setq vecx (HL:A_dxf 11 o))
  (setq vecy (HL:scalarMul ratio (list (HL:neg (cadr vecx)) (car vecx) (caddr vecx))))
  (setq sA (HL:A_dxf 41 o))
  (setq eA (HL:A_dxf 42 o))
  ;dxf 210 z -1 means reverse
  (if (HL:eqr -1.0 (caddr (HL:A_dxf 210 o)))
      (progn
	(setq vecx (mapcar 'HL:neg vecx))
	(setq vecy (mapcar 'HL:neg vecy))
      )
  )
  (setq pairList (mapcar 'cons (list 0 (HL:get90D) (HL:get180D) (HL:get270D)) (list (HL:+L center vecx) (HL:+L center vecy) (HL:-L center vecx) (HL:-L center vecy))))
  (foreach i pairList
     (if (or (HL:eqr sA eA) (HL:isInAngle sA eA (car i)))
         (setq angleL (cons (cdr i) angleL))
     )
  )
  angleL
)
(defun HL:difflist (a b)
  (while (and a b)
    	 (if (/= (car a) (car b))
	     (progn
	       (print a)
	       (print b)
	     )
	 )
         (setq a (cdr a))
         (setq b (cdr b))
  )
)
;random
(setq HL:RANDOM_SEED 100)
(defun HL:randinit () 
  (setq HL:RANDOM_SEED (HL:getseconds))
  (HL:randreal 1.0)
  (HL:randreal 1.0)
  (HL:randreal 1.0)
)
(defun HL:rand ( maxi ) 
  (fix (HL:randreal maxi))  
)
(defun HL:randreal (maxi)
  (setq HL:RANDOM_SEED (rem (* 48271.0 HL:RANDOM_SEED) 2147483647.0))  
  (* maxi (/ HL:RANDOM_SEED 2147483647.0))
)
(defun HL:randrealrange(mini maxi)
  (+ mini (HL:randreal (- maxi mini)))
)
(defun HL:randrange (mini maxi)
  (+ mini (HL:rand (- maxi mini)))
)
(defun HL:getseconds ( / s)
  (setq s (getvar "DATE"))
  (fix (* 86400.0 (- s (fix s))))
)
;for active-x
(setq HL:*acadobject* nil) ; Initialize global variable
(defun HL:acadobject ()
  (cond (HL:*acadobject*) ; Return the cached object
    (t
      (setq HL:*acadobject* (vlax-get-acad-object))
    )
  )
)

(setq HL:*activedocument* nil) ; Initialize global variable
(defun HL:activedocument ()
  (cond (HL:*active-document*) ; Return the cached object
    (t
      (setq HL:*activedocument* (vla-get-activedocument (HL:acadobject)))
    )
  )
)

(setq HL:*modelspace* nil) ; Initialize global variable
(defun HL:modelspace ()
  (cond (HL:*modelspace*) ; Return the cached object
    (t
      (setq HL:*modelspace* (vla-get-modelspace (HL:activedocument)))
    )
  )
)
(defun HL:drawCircle ( vertex r)
  (vla-addcircle (HL:modelspace) (vlax-3d-point vertex) r)
)
(defun HL:drawEname (ename / s e)
  (setq p (vlax-curve-getpointatparam ename (* 0.5 (+ (vlax-curve-getparamatpoint ename (vlax-curve-getstartpoint ename)) (vlax-curve-getparamatpoint ename (vlax-curve-getendpoint ename))))))
  (vla-addcircle (HL:modelspace) (vlax-3d-point p) 1)
)
(defun HL:joinAll (enamelist / ss ope)      
  (setq ope (getvar "PEDITACCEPT"))  
  (setq ss (HL:toSet enamelist))
  (setvar "PEDITACCEPT" 1)
  (command "_.pedit" "_M" ss "" "_J" "" "")
  (setvar "PEDITACCEPT" ope)
)
(princ)