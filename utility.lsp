
(setq HL:ISLOADUTILITY_LSP T)
(setq HL:CUSTOMEQUALQUALITY 0.00000001)
;common command
(defun HL:saveVar()
         (setq HL:OldOsmode (getvar "OSMODE"))
	(setq HL:OldLayer (getvar "CLAYER"))
	(setq HL:OldLType (getvar "CeLType"))
	(setq HL:OldColor (getvar "CeColor"))
	(setq HL:OldOrtho (getvar "ORTHOMODE"))
	(setq HL:OldDStyle  (getvar "DIMSTYLE"))
  (princ)
)
(defun HL:restoreVar()
  (setvar "OSMODE" HL:OldOsmode)
  (setvar "CLAYER" HL:OldLayer)
	(setvar "CeLType" HL:OldLType)
	(setvar "CeColor" HL:OldColor)
	(setvar "ORTHOMODE" HL:OldOrtho)
	(if (and (/= (getvar "DIMSTYLE") HL:OldDStyle)(tblsearch "DIMSTYLE" HL:OldDStyle))
	(command "-dimstyle" "Restore" HL:OldDStyle)
	)
  (princ)
) 
(defun HL:A_start ()
        (setq HL:OldCmdEcho (getvar "CMDECHO"))
	(setvar "CMDECHO" 0)
        (setq *error* HL:*myerror*)
        (*push-error-using-command*) 
	(command "undo" "be")	
	(princ)
)


(defun HL:AU_end ()
	(command "undo" "end")	
	(setvar "CMDECHO" HL:OldCmdEcho)
        (setq *error* nil)
	(princ)
)
(defun HL:A_end ()
	(HL:AU_end)
        (*pop-error-mode*) 
	(princ)
)
(defun HL:A_errorEnd()
  (HL:AU_end)
  (command "._U")
  (*pop-error-mode*)
  (princ)
)


(defun HL:*myerror* (msg)
	(HL:A_errorEnd)
	(princ msg)
	(princ)
)


(defun HL:A_dxf (g e)
	(cond
		((= (type e) 'ename) (cdr (assoc g (entget e))))
		((= (type e) 'list) (cdr (assoc g e)))
	)
)

(defun HL:U_dxf (g u e )
  (setq e
	(cond
		((= (type e) 'ename) (entget e))
		((= (type e) 'list) e)
	)
  )
  (if (assoc g e)
     (subst (cons g u) (assoc g e) e)
     (cons (cons g u) e)
  )
)
;*************point to string******
(defun HL:ptos (point)
  (strcat (rtos (car point)) " " (rtos (cadr point)))
  )
;*************"1,1"=> ("1","1")*****
(defun HL:split (SD_Str / DataTemp m DataS DataN SD_List)
            (setq DataTemp (vl-string->list SD_Str))
            (setq m 0)
            (repeat (length DataTemp)
            (if     (/= (nth m DataTemp) 32)
                (setq DataS (append DataS (list (nth m DataTemp))))
                (progn  (setq DataN (append DataN (list DataS)))
                        (setq DataS nil)
                )
            )
            (setq m (1+ m))
            )
            (setq DataN (append DataN (list DataS)))
            (setq SD_List (mapcar 'vl-list->string DataN))
            SD_List
        )
(defun HL:splitWith (SD_Str character / DataTemp m DataS DataN SD_List)
            (setq DataTemp (vl-string->list SD_Str))
            (setq m 0)
            (repeat (length DataTemp)
            (if     (/= (nth m DataTemp) (ascii character))
                (setq DataS (append DataS (list (nth m DataTemp))))
                (progn  (setq DataN (append DataN (list DataS)))
                        (setq DataS nil)
                )
            )
            (setq m (1+ m))
            )
            (setq DataN (append DataN (list DataS)))
            (setq SD_List (mapcar 'vl-list->string DataN))
            SD_List
        )
;take num from head
(defun HL:take (pL num)
  (if (or (not pL) (= num 0))
      nil
      (cons (car pL) (HL:take (cdr pL) (1- num)))
  )
  )
;list plus
(defun HL:+L (aL bL)
  (if (and aL bL)
      (cons (+ (car aL) (car bL)) (HL:+L (cdr aL) (cdr bL)))
    nil
    )
)
(defun HL:-L (aL bL)
  (if (and aL bL)
      (cons (- (car aL) (car bL)) (HL:-L (cdr aL) (cdr bL)))
    nil
    )
)
(defun HL:lessp (a b)
  (if (HL:eqr a b)
      t
      (<= a b)
  )
)
(defun HL:getD (p0 p1 / xx yy)
  (setq xx (- (car p0) (car p1)))
  (setq yy (- (cadr p0) (cadr p1)))
  (sqrt (+ (* xx xx) (* yy yy)))
)
(defun HL:getL (p0 / xx yy)
  (setq xx (car p0))
  (setq yy (cadr p0))
  (sqrt (+ (* xx xx) (* yy yy)))
)
;;return vector V length l
(defun HL:lengthV (v l / d)
  (setq d (HL:getL v))
  (list (* (/ (car v) d) l) (* (/ (cadr v) d) l))
)

(defun HL:rotate90 (v)
  (list (cadr v)(- 0 (car v)))
)
(defun HL:scalarMul(a aL)
  (mapcar '(lambda (x) (* a x)) aL)
)
(defun HL:outerproduct ( v0 v1 / )
  (- (* (car v0) (car (cdr v1))) (* (car v1) (car (cdr v0))))
)
(defun HL:innerproduct ( v0 v1 / )
  (+ (* (car v0) (car v1)) (* (cadr v0) (cadr v1)))
)
(defun HL:neg (a)
  (- 0 a)
)
;real eq
(defun HL:eqr(x y)
  (equal x y HL:CUSTOMEQUALQUALITY)
)
;2d point <
(defun HL:compp (p0 p1 / x0 x1 y0 y1)
  (setq x0 (car p0))
  (setq y0 (cadr p0))
  (setq x1 (car p1))
  (setq y1 (cadr p1))
  (if (equal x0 x1 HL:CUSTOMEQUALQUALITY)
      (< y0 y1)
      (< x0 x1)
  )
)
;2d point eq
(defun HL:eqp (p0 p1 / x0 x1 y0 y1)
  (setq x0 (car p0))
  (setq y0 (cadr p0))
  (setq x1 (car p1))
  (setq y1 (cadr p1))
  (if (HL:eqr x0 x1)
      (HL:eqr y0 y1)
      nil
  )
)
;get All curve around point
(defun HL:getCurveSetAroundPoint (point)
  (ssget "_C" (HL:+L point '(0.1 0.1)) (HL:+L point '(-0.1 -0.1)) '((0 . "ARC,CIRCLE,LINE,LWPOLYLINE,SPLINE,ELLIPSE")))
)

(defun HL:isCurve (item)
   (member (HL:A_dxf 0 item) '("ARC" "CIRCLE" "LINE" "LWPOLYLINE" "SPLINE" "ELLIPSE"))
)
;point is on curve except oname
(defun HL:isOnCurve(oname point / ObjSet i0 name isok)
  (setq ObjSet (HL:getCurveSetAroundPoint point))
  (setq i0 -1)
  (setq isok nil)
  (if (not ObjSet)
     nil;(progn (princ "オブジェクトなし") (princ))
     (progn
       (repeat (sslength ObjSet)
        (setq name (ssname ObjSet (setq i0 (1+ i0))))
        (if (equal name oname)
           nil
           (if (HL:eqp (vlax-curve-getClosestPointTo  name point) point)
             (setq isok t)
          )
        )
     )
     isok
     )
 )
)
(defun HL:isOnCurveEndPoint(oname point / ObjSet i0 name pointL isOn p)
  (setq ObjSet (HL:getCurveSetAroundPoint point))
  (setq i0 -1)
  (setq pointL nil)
  (if (not ObjSet)
    nil
    (progn 
  (repeat (sslength ObjSet)
	  (setq name (ssname ObjSet (setq i0 (1+ i0))))
    	  (if (not (equal name oname))
    	      (setq pointL (cons (vlax-curve-getEndPoint name ) (cons (vlax-curve-getStartPoint name) pointL)))
          )
  )
  (setq isOn nil)
  (foreach p pointL
    (if (HL:eqp p point)
        (setq isOn t)
    )
  )
  isOn
  )
  )
)
(defun HL:isOnCurveEndAndQuadrantPoint(oname point / ObjSet i0 name pointL isOn p)
  (setq ObjSet (HL:getCurveSetAroundPoint point))
  (setq i0 -1)
  (setq pointL nil)
  (if (not ObjSet)
    nil
    (progn 
  (repeat (sslength ObjSet)
	  (setq name (ssname ObjSet (setq i0 (1+ i0))))
    	  (if (not (equal name oname))
	      (progn
    	        (setq pointL (cons (vlax-curve-getEndPoint name ) (cons (vlax-curve-getStartPoint name) pointL)))
		(cond ((or (= (HL:getType name) "ARC") (= (HL:getType name) "CIRCLE")) (setq pointL (append (HL:getQuadrantPoint name) pointL)))
		      ((= (HL:getType name) "ELLIPSE") (setq pointL (append (HL:getEllipseQuadrantPoint name) pointL)))
		)
	      )
          )
  )
  (setq isOn nil)
  (foreach p pointL
    (if (HL:eqp p point)
        (setq isOn t)
    )
  )
  isOn
  )
  )
)

;select set to ename list
(defun HL:getNameList (set / pL i)
  (if (/= set nil)
    (progn
  (setq i 0)
  (repeat (sslength set)
      (setq pL (cons (ssname set i) pL))
      (setq i (1+ i))
  )
  pL
  )
  nil
  )
)

(defun HL:getCurveLength (item)
  (vlax-curve-getDistAtParam item (vlax-curve-getEndParam item))
)
;ename list to select set
(defun HL:toSet(nL / ss item)
  (setq ss (ssadd))
  (foreach item nL
    (setq ss (ssadd item ss))
  )
)

(defun HL:changeColor(e c)
  (command-s "._chprop" e "" "C" c "")
)
;recursively explode blocks and return the list of enames
(defun HL:explodeBlocksAndGetNameList(nL / name tL rL)
  (while nL
   (setq tL nil)
   (foreach name nL
     (if (equal (HL:A_dxf 0 name) "INSERT")
         (progn 
          (command "._explode" name)
           (setq tL (append (HL:getNameList (ssget "p")) tL))
	 )
         (setq rL (cons name rL))
     )
   )
   (setq nL tL)
  )
  rL
)
(defun HL:changeToBlock ( ss )
  (if (listp ss)
      (setq ss (HL:toSet ss))
  )
  (command "._copybase" '(0 0) ss "")
  (command "._pasteblock" '(0 0))
  (command "._erase" ss "")
  (princ)
)
;return the ename list of block
(defun HL:getBlockEntities (insertBlockName / entity rL)
  (setq entity (tblobjname "block" (HL:A_dxf 2 insertBlockName)))
  (while (setq entity (entnext entity))
    (setq rL (cons entity rL))
  )
)
;
(defun HL:intersparse (list object)
  (if (cdr list)
      (cons (car list) (cons object (HL:intersparse (cdr list) object)))
      list
    )
)
;
(defun HL:joinStr(strList str)
  (apply 'strcat (HL:intersparse strList str))
  )
(defun HL:isInAngle(sa ea a)
  (while (>= sa (* 2 pi))
     (setq sa (- sa (* 2 pi)))
  )
  (while (>= ea (* 2 pi))
     (setq ea (- ea (* 2 pi)))
  )
  (if (HL:eqr sa ea)
       t
      (if (HL:lessp sa ea)
        (and (HL:lessp sa a) (HL:lessp a ea))
        (or (and (HL:lessp sa a) (HL:lessp a (* 2.0 PI))) (and (HL:lessp 0 a) (HL:lessp a ea)))
      )
  )
)
;;
(defun HL:getType (o)
  (HL:A_dxf 0 o)
)
(defun HL:getRadius(o)
  (HL:A_dxf 40 o)
)
(defun HL:getStartAngle(o)
  (HL:A_dxf 50 o)
)
(defun HL:getEndAngle(o)
  (HL:A_dxf 51 o)
)
(defun HL:getColor(o)
  (HL:A_dxf 62 o)
)
(defun HL:getCenter(o)
  (HL:A_dxf 10 o)
)
(defun HL:get90D()
  (* 0.5 pi)
)
(defun HL:get180D()
  (* 1.0 pi)
)
(defun HL:get270D()
  (* 1.5 pi)
)
;return point on object o at angle a
(defun HL:getCirclePoint (o a / otype)
  (setq otype (HL:getType o))
  (if (or (equal otype "ARC") (equal otype "CIRCLE"))
      (polar (HL:getCenter o) a (HL:getRadius o))
      (ErrorNotArcOrCircle)
  )
)
(defun HL:_getEdgePoint(o / sa ea cp r sp ep)
  (setq sa (HL:getStartAngle o))
  (setq ea (HL:getEndAngle o))
  (setq cp (HL:getCenter o))
  (setq r (HL:getRadius o))
  (setq sp (polar cp sa r))
  (setq ep (polar cp ea r))
  (inters sp (polar sp (+ sa (HL:get90D)) r) ep (polar ep (+ ea (HL:get90D)) r) nil)
)
;;ARC intersect point; fillet point
(defun HL:getEdgePoint(o / otype)
  (setq otype (HL:getType o))
  (if (equal otype "ARC")
      (HL:_getEdgePoint o)
      (ErrorNotARC)
  )
)
(defun HL:vlax-ldata-erase (dict / key)
  (foreach key (mapcar 'car (vlax-ldata-list dict)) (vlax-ldata-delete dict key))
  )
(defun HL:changeToGroup (objSet)
  (command "._group" "C" "*" "*" objSet "")
  )
(defun HL:getQuadrantPoint(o / angleL a sA eA)
  (setq angleL nil)
  (setq sA (HL:getStartAngle o))
  (setq eA (HL:getEndAngle o))
  (foreach a (list 0 (HL:get90D) (HL:get180D) (HL:get270D))
    (if (or (= (HL:getType o) "CIRCLE") (HL:isInAngle sA eA a))
        (setq angleL (cons (HL:getCirclePoint o a) angleL))
    )
  )
  angleL
)
(defun HL:getIntersectPoints (ename0 ename / intPoints tempPoint pl)
  (setq intPoints (vla-IntersectWith (vlax-ename->vla-object ename0) (vlax-ename->vla-object ename) acExtendNone))         
  (if (/= (type intPoints) vlax-vbEmpty)        
      (progn
        (setq tempPoint (vlax-safearray->list (vlax-variant-value intPoints)))  ;交点リストを取得
        (while tempPoint
          (setq
            pl (cons (list (car tempPoint) (cadr tempPoint) (caddr tempPoint)) pl)
            tempPoint (cdddr tempPoint)
          )
        )
      )
  )
  pl
)
(defun HL:getEllipseQuadrantPoint(o / angleL center vecx vecy ratio sA eA pairList i)
  (setq angleL nil)
  (setq center (HL:getCenter o))
  (setq ratio (HL:A_dxf 40 o))
  (setq vecx (HL:A_dxf 11 o))
  (setq vecy (HL:scalarMul ratio (list (HL:neg (cadr vecx)) (car vecx) (caddr vecx))))
  (setq sA (HL:A_dxf 41 o))
  (setq eA (HL:A_dxf 42 o))
  ;dxf 210 z -1 means reverse
  (if (HL:eqr -1.0 (caddr (HL:A_dxf 210 o)))
      (progn
	(setq vecx (mapcar 'HL:neg vecx))
	(setq vecy (mapcar 'HL:neg vecy))
      )
  )
  (setq pairList (mapcar 'cons (list 0 (HL:get90D) (HL:get180D) (HL:get270D)) (list (HL:+L center vecx) (HL:+L center vecy) (HL:-L center vecx) (HL:-L center vecy))))
  (foreach i pairList
     (if (or (HL:eqr sA eA) (HL:isInAngle sA eA (car i)))
         (setq angleL (cons (cdr i) angleL))
     )
  )
  angleL
)
(defun HL:difflist (a b)
  (while (and a b)
    	 (if (/= (car a) (car b))
	     (progn
	       (print a)
	       (print b)
	     )
	 )
         (setq a (cdr a))
         (setq b (cdr b))
  )
)
;random
(setq HL:RANDOM_SEED 100)
(defun HL:randinit () 
  (setq HL:RANDOM_SEED (HL:getseconds))
  (HL:randreal 1.0)
  (HL:randreal 1.0)
  (HL:randreal 1.0)
)
(defun HL:rand ( maxi ) 
  (fix (HL:randreal maxi))  
)
(defun HL:randreal (maxi)
  (setq HL:RANDOM_SEED (rem (* 48271.0 HL:RANDOM_SEED) 2147483647.0))  
  (* maxi (/ HL:RANDOM_SEED 2147483647.0))
)
(defun HL:randrealrange(mini maxi)
  (+ mini (HL:randreal (- maxi mini)))
)
(defun HL:randrange (mini maxi)
  (+ mini (HL:rand (- maxi mini)))
)
(defun HL:getseconds ( / s)
  (setq s (getvar "DATE"))
  (fix (* 86400.0 (- s (fix s))))
)
;for active-x
(setq HL:*acadobject* nil) ; Initialize global variable
(defun HL:acadobject ()
  (cond (HL:*acadobject*) ; Return the cached object
    (t
      (setq HL:*acadobject* (vlax-get-acad-object))
    )
  )
)

(setq HL:*activedocument* nil) ; Initialize global variable
(defun HL:activedocument ()
  (cond (HL:*active-document*) ; Return the cached object
    (t
      (setq HL:*activedocument* (vla-get-activedocument (HL:acadobject)))
    )
  )
)

(setq HL:*modelspace* nil) ; Initialize global variable
(defun HL:modelspace ()
  (cond (HL:*modelspace*) ; Return the cached object
    (t
      (setq HL:*modelspace* (vla-get-modelspace (HL:activedocument)))
    )
  )
)
(defun HL:drawCircle ( vertex r)
  (vla-addcircle (HL:modelspace) (vlax-3d-point vertex) r)
)
(defun HL:drawLine ( vertex0 vertex1 )
  (vla-AddLine (HL:modelSpace) (vlax-3d-point vertex0) (valx-3d-point vertex1))  
)
(defun HL:drawRectangle ( v0 v1 / minx miny maxx maxy)
  (setq minx (min (car v0) (car v1)))
  (setq maxx (max (car v0) (car v1)))
  (setq miny (min (cadr v0) (cadr v1)))
  (setq maxy (max (cadr v0) (cadr v1)))
  (vla-AddLine (HL:modelSpace) (vlax-3d-point (list minx miny)) (vlax-3d-point (list minx maxy)))  
  (vla-AddLine (HL:modelSpace) (vlax-3d-point (list minx maxy)) (vlax-3d-point (list maxx maxy)))  
  (vla-AddLine (HL:modelSpace) (vlax-3d-point (list maxx maxy)) (vlax-3d-point (list maxx miny)))  
  (vla-AddLine (HL:modelSpace) (vlax-3d-point (list maxx miny)) (vlax-3d-point (list minx miny)))  
)

(defun HL:drawEname (ename / s e)
  (setq p (vlax-curve-getpointatparam e name (* 0.5 (+ (vlax-curve-getparamatpoint ename (vlax-curve-getstartpoint ename)) (vlax-curve-getparamatpoint ename (vlax-curve-getendpoint ename))))))
  (vla-addcircle (HL:modelspace) (vlax-3d-point p) 1)
)
(defun HL:joinAll (enamelist / ss ope)      
  (setq ope (getvar "PEDITACCEPT"))  
  (setq ss (HL:toSet enamelist))
  (setvar "PEDITACCEPT" 1)
  (command "_.pedit" "_M" ss "" "_J" "" "")
  (setvar "PEDITACCEPT" ope)
)
(defun HL:drawBoundingBox (b)
  (HL:drawRectangle (car b) (cdr b))
)
(defun HL:isCrossRange ( min0 max0 min1 max1)
  (or (and (<= min0 min1) (<= min1 max0 )) (and (<= min0 max1) (<= max1 max0 ))
      (and (<= min1 min0) (<= min0 max1 )) (and (<= min1 max0) (<= max0 max1 ))
  )
)
(defun HL:isBoundingBoxCross ( pcons0 pcons1 / p0min p0max p1min p1max)  
  (setq p0min (car pcons0))
  (setq p0max (cdr pcons0))
  (setq p1min (car pcons1))
  (setq p1max (cdr pcons1))
  (and (HL:isCrossRange (car p0min) (car p0max) (car p1min) (car p1max))
       (HL:isCrossRange (cadr p0min) (cadr p0max) (cadr p1min) (cadr p1max))
  )
)
(defun HL:mergeBoundingBox ( b0 b1 / p0min p0max p1min p1max)
  (setq p0min (car b0))
  (setq p0max (cdr b0))
  (setq p1min (car b1))
  (setq p1max (cdr b1))
  (cons (list (min (car p0min) (car p1min)) (min (cadr p0min) (cadr p1min))) (list (max (car p0max) (car p1max)) (max (cadr p0max) (cadr p1max))))
)
(defun HL:getBoundingBox (ent / obj minpt maxpt)  
  (setq obj (vlax-ename->vla-object ent))
  (vla-getboundingbox obj 'minpt 'maxpt)
  (setq minpt (vlax-safearray->list minpt))
  (setq maxpt (vlax-safearray->list maxpt))
  (setq minpt (list (car minpt) (cadr minpt)))
  (setq maxpt (list (car maxpt) (cadr maxpt)))
  (cons minpt maxpt)
)
(princ)